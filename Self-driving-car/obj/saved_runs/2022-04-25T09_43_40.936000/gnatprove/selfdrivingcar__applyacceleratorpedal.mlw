module Selfdrivingcar__gearbox
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type gearbox
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (2 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = gearbox,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type gearbox__ref = { mutable gearbox__content : gearbox }
  
  function gearbox__ref_gearbox__content__projection (a: gearbox__ref) : gearbox =
    a.gearbox__content
  
  meta "model_projection" function gearbox__ref_gearbox__content__projection
  
  meta "inline:no" function gearbox__ref_gearbox__content__projection
  
  val gearbox__havoc (x: gearbox__ref) : unit
    writes { x }
end

module Selfdrivingcar__gearbox__rep
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__gearbox.gearbox,
    predicate in_range = Selfdrivingcar__gearbox.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__sensor
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type sensor
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = sensor,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type sensor__ref = { mutable sensor__content : sensor }
  
  function sensor__ref_sensor__content__projection (a: sensor__ref) : sensor =
    a.sensor__content
  
  meta "model_projection" function sensor__ref_sensor__content__projection
  
  meta "inline:no" function sensor__ref_sensor__content__projection
  
  val sensor__havoc (x: sensor__ref) : unit
    writes { x }
end

module Selfdrivingcar__sensor__rep
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__sensor.sensor,
    predicate in_range = Selfdrivingcar__sensor.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__ignition
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type ignition
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = ignition,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type ignition__ref = { mutable ignition__content : ignition }
  
  function ignition__ref_ignition__content__projection (a: ignition__ref) : ignition =
    a.ignition__content
  
  meta "model_projection" function ignition__ref_ignition__content__projection
  
  meta "inline:no" function ignition__ref_ignition__content__projection
  
  val ignition__havoc (x: ignition__ref) : unit
    writes { x }
end

module Selfdrivingcar__ignition__rep
  use Selfdrivingcar__ignition as Selfdrivingcar__ignition
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__ignition.ignition,
    predicate in_range = Selfdrivingcar__ignition.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__diagnostics
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type diagnostics
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = diagnostics,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type diagnostics__ref = { mutable diagnostics__content : diagnostics }
  
  function diagnostics__ref_diagnostics__content__projection (a: diagnostics__ref) : diagnostics =
    a.diagnostics__content
  
  meta "model_projection" function diagnostics__ref_diagnostics__content__projection
  
  meta "inline:no" function diagnostics__ref_diagnostics__content__projection
  
  val diagnostics__havoc (x: diagnostics__ref) : unit
    writes { x }
end

module Selfdrivingcar__diagnostics__rep
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__diagnostics.diagnostics,
    predicate in_range = Selfdrivingcar__diagnostics.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__speed
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type speed = <range 0 70>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (70 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = speed,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type speed__ref = { mutable speed__content : speed }
  
  function speed__ref_speed__content__projection (a: speed__ref) : speed =
    a.speed__content
  
  meta "model_projection" function speed__ref_speed__content__projection
  
  meta "inline:no" function speed__ref_speed__content__projection
  
  val speed__havoc (x: speed__ref) : unit
    writes { x }
end

module Selfdrivingcar__speed__rep
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Selfdrivingcar__speed.speed) : int =
    Selfdrivingcar__speed.speed'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__speed.speed,
    predicate in_range = Selfdrivingcar__speed.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__batterypercentage
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type batterypercentage = <range 0 100>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (100 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = batterypercentage,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type batterypercentage__ref = {
                               mutable batterypercentage__content :
                                 batterypercentage
                               }
  
  function batterypercentage__ref_batterypercentage__content__projection (a: batterypercentage__ref) : batterypercentage =
    a.batterypercentage__content
  
  meta "model_projection" function batterypercentage__ref_batterypercentage__content__projection
  
  meta "inline:no" function batterypercentage__ref_batterypercentage__content__projection
  
  val batterypercentage__havoc (x: batterypercentage__ref) : unit
    writes { x }
end

module Selfdrivingcar__batterypercentage__rep
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Selfdrivingcar__batterypercentage.batterypercentage) : int =
    Selfdrivingcar__batterypercentage.batterypercentage'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__batterypercentage.batterypercentage,
    predicate in_range = Selfdrivingcar__batterypercentage.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__car__rep
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  use Selfdrivingcar__gearbox__rep as Selfdrivingcar__gearbox__rep
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  use Selfdrivingcar__sensor__rep as Selfdrivingcar__sensor__rep
  use Selfdrivingcar__ignition as Selfdrivingcar__ignition
  use Selfdrivingcar__ignition__rep as Selfdrivingcar__ignition__rep
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  use Selfdrivingcar__diagnostics__rep as Selfdrivingcar__diagnostics__rep
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  use Selfdrivingcar__speed__rep as Selfdrivingcar__speed__rep
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  use Selfdrivingcar__batterypercentage__rep as Selfdrivingcar__batterypercentage__rep
  
  type __split_fields = {
                       rec__selfdrivingcar__car__gearengaged :
                         Selfdrivingcar__gearbox.gearbox;
                       rec__selfdrivingcar__car__objectscanner :
                         Selfdrivingcar__sensor.sensor;
                       rec__selfdrivingcar__car__status :
                         Selfdrivingcar__ignition.ignition;
                       rec__selfdrivingcar__car__diagnosticmode :
                         Selfdrivingcar__diagnostics.diagnostics;
                       rec__selfdrivingcar__car__currentspeed :
                         Selfdrivingcar__speed.speed;
                       rec__selfdrivingcar__car__batterycharge :
                         Selfdrivingcar__batterypercentage.batterypercentage
                       }
  
  function __split_fields_rec__selfdrivingcar__car__gearengaged__projection (a: __split_fields) : 
    Selfdrivingcar__gearbox.gearbox =
    a.rec__selfdrivingcar__car__gearengaged
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__gearengaged__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__gearengaged__projection
  
  function __split_fields_rec__selfdrivingcar__car__objectscanner__projection (a: __split_fields) : 
    Selfdrivingcar__sensor.sensor =
    a.rec__selfdrivingcar__car__objectscanner
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__objectscanner__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__objectscanner__projection
  
  function __split_fields_rec__selfdrivingcar__car__status__projection (a: __split_fields) : 
    Selfdrivingcar__ignition.ignition =
    a.rec__selfdrivingcar__car__status
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__status__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__status__projection
  
  function __split_fields_rec__selfdrivingcar__car__diagnosticmode__projection (a: __split_fields) : 
    Selfdrivingcar__diagnostics.diagnostics =
    a.rec__selfdrivingcar__car__diagnosticmode
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__diagnosticmode__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__diagnosticmode__projection
  
  function __split_fields_rec__selfdrivingcar__car__currentspeed__projection (a: __split_fields) : 
    Selfdrivingcar__speed.speed =
    a.rec__selfdrivingcar__car__currentspeed
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__currentspeed__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__currentspeed__projection
  
  function __split_fields_rec__selfdrivingcar__car__batterycharge__projection (a: __split_fields) : 
    Selfdrivingcar__batterypercentage.batterypercentage =
    a.rec__selfdrivingcar__car__batterycharge
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__batterycharge__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__batterycharge__projection
  
  type __split_fields__ref = {
                            mutable __split_fields__content : __split_fields
                            }
  
  function __split_fields__ref___split_fields__content__projection (a: __split_fields__ref) : __split_fields =
    __split_fields__content a
  
  meta "model_projection" function __split_fields__ref___split_fields__content__projection
  
  meta "inline:no" function __split_fields__ref___split_fields__content__projection
  
  val __split_fields__havoc (x: __split_fields__ref) : unit
    writes { x }
  
  type __rep = { __split_fields : __split_fields }
  
  function __rep___split_fields__projection (a: __rep) : __split_fields =
    __split_fields a
  
  meta "model_projection" function __rep___split_fields__projection
  
  meta "inline:no" function __rep___split_fields__projection
  
  function to_base (a: __rep) : __rep = a
  
  val to_base (a: __rep) : __rep
    ensures { result = (to_base (a : __rep)) }
  
  function of_base (a: __rep) : __rep = a
  
  val of_base (a: __rep) : __rep
    ensures { result = (of_base (a : __rep)) }
  
  predicate selfdrivingcar__car__gearengaged__pred (a: __rep) = true
  
  val selfdrivingcar__car__gearengaged__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__gearengaged__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__gearengaged_ (a: __rep) : Selfdrivingcar__gearbox.gearbox
    requires { selfdrivingcar__car__gearengaged__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__gearengaged)) }
  
  predicate selfdrivingcar__car__objectscanner__pred (a: __rep) = true
  
  val selfdrivingcar__car__objectscanner__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__objectscanner__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__objectscanner_ (a: __rep) : Selfdrivingcar__sensor.sensor
    requires { selfdrivingcar__car__objectscanner__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__objectscanner)) }
  
  predicate selfdrivingcar__car__status__pred (a: __rep) = true
  
  val selfdrivingcar__car__status__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__status__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__status_ (a: __rep) : Selfdrivingcar__ignition.ignition
    requires { selfdrivingcar__car__status__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__status)) }
  
  predicate selfdrivingcar__car__diagnosticmode__pred (a: __rep) = true
  
  val selfdrivingcar__car__diagnosticmode__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__diagnosticmode__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__diagnosticmode_ (a: __rep) : Selfdrivingcar__diagnostics.diagnostics
    requires { selfdrivingcar__car__diagnosticmode__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__diagnosticmode)) }
  
  predicate selfdrivingcar__car__currentspeed__pred (a: __rep) = true
  
  val selfdrivingcar__car__currentspeed__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__currentspeed__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__currentspeed_ (a: __rep) : Selfdrivingcar__speed.speed
    requires { selfdrivingcar__car__currentspeed__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__currentspeed)) }
  
  predicate selfdrivingcar__car__batterycharge__pred (a: __rep) = true
  
  val selfdrivingcar__car__batterycharge__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__batterycharge__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__batterycharge_ (a: __rep) : Selfdrivingcar__batterypercentage.batterypercentage
    requires { selfdrivingcar__car__batterycharge__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__batterycharge)) }
  
  function bool_eq (a: __rep) (b: __rep) : bool =
    if ((((Selfdrivingcar__gearbox__rep.to_rep
             ((__split_fields a).rec__selfdrivingcar__car__gearengaged))
            = (Selfdrivingcar__gearbox__rep.to_rep
                 ((__split_fields b).rec__selfdrivingcar__car__gearengaged))) /\
           ((Selfdrivingcar__sensor__rep.to_rep
               ((__split_fields a).rec__selfdrivingcar__car__objectscanner))
              = (Selfdrivingcar__sensor__rep.to_rep
                   ((__split_fields b).rec__selfdrivingcar__car__objectscanner)))) /\
          ((((Selfdrivingcar__ignition__rep.to_rep
                ((__split_fields a).rec__selfdrivingcar__car__status))
               = (Selfdrivingcar__ignition__rep.to_rep
                    ((__split_fields b).rec__selfdrivingcar__car__status))) /\
              ((Selfdrivingcar__diagnostics__rep.to_rep
                  ((__split_fields a).rec__selfdrivingcar__car__diagnosticmode))
                 = (Selfdrivingcar__diagnostics__rep.to_rep
                      ((__split_fields b).rec__selfdrivingcar__car__diagnosticmode)))) /\
             (((Selfdrivingcar__speed__rep.to_rep
                  ((__split_fields a).rec__selfdrivingcar__car__currentspeed))
                 = (Selfdrivingcar__speed__rep.to_rep
                      ((__split_fields b).rec__selfdrivingcar__car__currentspeed))) /\
                ((Selfdrivingcar__batterypercentage__rep.to_rep
                    ((__split_fields a).rec__selfdrivingcar__car__batterycharge))
                   = (Selfdrivingcar__batterypercentage__rep.to_rep
                        ((__split_fields b).rec__selfdrivingcar__car__batterycharge)))))) then
      True
    else False
  
  val bool_eq (a: __rep) (b: __rep) : bool
    ensures { result = ((bool_eq (a : __rep)) (b : __rep)) }
end

module Selfdrivingcar__car
  use export Selfdrivingcar__car__rep
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type car = __rep
  
  val function value__size : int
  
  val function object__size : int
  
  val function alignment : int
  
  axiom value__size_axiom: (value__size >= (0 : int))
  
  axiom object__size_axiom: (object__size >= (0 : int))
  
  axiom alignment_axiom: (alignment >= (0 : int))
  
  val function selfdrivingcar__car__gearengaged__first__bit : int
  
  val function selfdrivingcar__car__gearengaged__last__bit : int
  
  val function selfdrivingcar__car__gearengaged__position : int
  
  axiom selfdrivingcar__car__gearengaged__first__bit_axiom:
    (selfdrivingcar__car__gearengaged__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__gearengaged__last__bit_axiom:
    (selfdrivingcar__car__gearengaged__last__bit
       > selfdrivingcar__car__gearengaged__first__bit)
  
  axiom selfdrivingcar__car__gearengaged__position_axiom:
    (selfdrivingcar__car__gearengaged__position >= (0 : int))
  
  val function selfdrivingcar__car__objectscanner__first__bit : int
  
  val function selfdrivingcar__car__objectscanner__last__bit : int
  
  val function selfdrivingcar__car__objectscanner__position : int
  
  axiom selfdrivingcar__car__objectscanner__first__bit_axiom:
    (selfdrivingcar__car__objectscanner__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__objectscanner__last__bit_axiom:
    (selfdrivingcar__car__objectscanner__last__bit
       > selfdrivingcar__car__objectscanner__first__bit)
  
  axiom selfdrivingcar__car__objectscanner__position_axiom:
    (selfdrivingcar__car__objectscanner__position >= (0 : int))
  
  val function selfdrivingcar__car__status__first__bit : int
  
  val function selfdrivingcar__car__status__last__bit : int
  
  val function selfdrivingcar__car__status__position : int
  
  axiom selfdrivingcar__car__status__first__bit_axiom:
    (selfdrivingcar__car__status__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__status__last__bit_axiom:
    (selfdrivingcar__car__status__last__bit
       > selfdrivingcar__car__status__first__bit)
  
  axiom selfdrivingcar__car__status__position_axiom:
    (selfdrivingcar__car__status__position >= (0 : int))
  
  val function selfdrivingcar__car__diagnosticmode__first__bit : int
  
  val function selfdrivingcar__car__diagnosticmode__last__bit : int
  
  val function selfdrivingcar__car__diagnosticmode__position : int
  
  axiom selfdrivingcar__car__diagnosticmode__first__bit_axiom:
    (selfdrivingcar__car__diagnosticmode__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__diagnosticmode__last__bit_axiom:
    (selfdrivingcar__car__diagnosticmode__last__bit
       > selfdrivingcar__car__diagnosticmode__first__bit)
  
  axiom selfdrivingcar__car__diagnosticmode__position_axiom:
    (selfdrivingcar__car__diagnosticmode__position >= (0 : int))
  
  val function selfdrivingcar__car__currentspeed__first__bit : int
  
  val function selfdrivingcar__car__currentspeed__last__bit : int
  
  val function selfdrivingcar__car__currentspeed__position : int
  
  axiom selfdrivingcar__car__currentspeed__first__bit_axiom:
    (selfdrivingcar__car__currentspeed__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__currentspeed__last__bit_axiom:
    (selfdrivingcar__car__currentspeed__last__bit
       > selfdrivingcar__car__currentspeed__first__bit)
  
  axiom selfdrivingcar__car__currentspeed__position_axiom:
    (selfdrivingcar__car__currentspeed__position >= (0 : int))
  
  val function selfdrivingcar__car__batterycharge__first__bit : int
  
  val function selfdrivingcar__car__batterycharge__last__bit : int
  
  val function selfdrivingcar__car__batterycharge__position : int
  
  axiom selfdrivingcar__car__batterycharge__first__bit_axiom:
    (selfdrivingcar__car__batterycharge__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__batterycharge__last__bit_axiom:
    (selfdrivingcar__car__batterycharge__last__bit
       > selfdrivingcar__car__batterycharge__first__bit)
  
  axiom selfdrivingcar__car__batterycharge__position_axiom:
    (selfdrivingcar__car__batterycharge__position >= (0 : int))
  
  val function user_eq (a: car) (b: car) : bool
  
  val function dummy : car
  
  type car__ref = { mutable car__content : car }
  
  function car__ref_car__content__projection (a: car__ref) : car =
    a.car__content
  
  meta "model_projection" function car__ref_car__content__projection
  
  meta "inline:no" function car__ref_car__content__projection
  
  val car__havoc (x: car__ref) : unit
    writes { x }
end

module Selfdrivingcar__mycar
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  val mycar__split_fields : Selfdrivingcar__car.__split_fields__ref
end

module Selfdrivingcar__car___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  predicate dynamic_invariant (temp___expr_217: Selfdrivingcar__car.car) (temp___is_init_213: bool) (temp___skip_constant_214: bool) (temp___do_toplevel_215: bool) (temp___do_typ_inv_216: bool) =
    true
  
  val dynamic_invariant (temp___expr_217: Selfdrivingcar__car.car) (temp___is_init_213: bool) (temp___skip_constant_214: bool) (temp___do_toplevel_215: bool) (temp___do_typ_inv_216: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_217 : Selfdrivingcar__car.car))
                      (temp___is_init_213 : bool))
                     (temp___skip_constant_214 : bool))
                    (temp___do_toplevel_215 : bool))
                   (temp___do_typ_inv_216 : bool)) }
  
  predicate default_initial_assumption (temp___expr_218: Selfdrivingcar__car.car) (temp___skip_top_level_219: bool) =
    true
  
  val default_initial_assumption (temp___expr_218: Selfdrivingcar__car.car) (temp___skip_top_level_219: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_218 : Selfdrivingcar__car.car))
                   (temp___skip_top_level_219 : bool)) }
end

module Selfdrivingcar__invariant
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  val function invariant__ (Selfdrivingcar__mycar___mycar__split_fields___: 
    Selfdrivingcar__car.__split_fields) : bool
  
  val predicate invariant____function_guard (temp___result_163: bool) (Selfdrivingcar__mycar___mycar__split_fields___: 
    Selfdrivingcar__car.__split_fields)
end

module Selfdrivingcar__invariant___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__mycar as Selfdrivingcar__mycar
  use Selfdrivingcar__car as Selfdrivingcar__car
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__invariant as Selfdrivingcar__invariant
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  use Selfdrivingcar__diagnostics__rep as Selfdrivingcar__diagnostics__rep
  
  val invariant__ (__void_param: unit) : bool
    reads { Selfdrivingcar__mycar.mycar__split_fields }
    requires { true }
    writes {  }
    ensures { (((result
                   = (Selfdrivingcar__invariant.invariant__
                        (Selfdrivingcar__car.__split_fields__content
                            Selfdrivingcar__mycar.mycar__split_fields))) /\
                  ((Selfdrivingcar__invariant.invariant____function_guard
                      result)
                     (Selfdrivingcar__car.__split_fields__content
                         Selfdrivingcar__mycar.mycar__split_fields))) /\
                 (result
                    = ((Selfdrivingcar__diagnostics__rep.to_rep
                          ((Selfdrivingcar__car.__split_fields
                               { Selfdrivingcar__car.__split_fields =
                                   (Selfdrivingcar__car.__split_fields__content
                                       Selfdrivingcar__mycar.mycar__split_fields) }).
                             Selfdrivingcar__car.rec__selfdrivingcar__car__diagnosticmode))
                         <> (0 : int)))) }
  
  axiom invariant____post_axiom:
    forall Selfdrivingcar__mycar___mycar__split_fields___ : Selfdrivingcar__car.__split_fields
          [Selfdrivingcar__invariant.invariant__
             Selfdrivingcar__mycar___mycar__split_fields___].
      ((((((Selfdrivingcar__car___axiom.dynamic_invariant
              { Selfdrivingcar__car.__split_fields =
                  Selfdrivingcar__mycar___mycar__split_fields___ })
             True)
            True)
           True)
          True) ->
         (let result =
            Selfdrivingcar__invariant.invariant__
              Selfdrivingcar__mycar___mycar__split_fields___ in
          if ((Selfdrivingcar__invariant.invariant____function_guard result)
                Selfdrivingcar__mycar___mycar__split_fields___) then
            ((true /\ true) /\ true)
          else true))
  
  axiom invariant____def_axiom:
    forall Selfdrivingcar__mycar___mycar__split_fields___ : Selfdrivingcar__car.__split_fields
          [Selfdrivingcar__invariant.invariant__
             Selfdrivingcar__mycar___mycar__split_fields___].
      ((Selfdrivingcar__invariant.invariant__
          Selfdrivingcar__mycar___mycar__split_fields___)
         = ((Selfdrivingcar__diagnostics__rep.to_rep
               ((Selfdrivingcar__car.__split_fields
                    { Selfdrivingcar__car.__split_fields =
                        Selfdrivingcar__mycar___mycar__split_fields___ }).
                  Selfdrivingcar__car.rec__selfdrivingcar__car__diagnosticmode))
              <> (0 : int)))
end

module Selfdrivingcar__applyacceleratorpedal__speedlimit
  use _gnatprove_standard.Main
  use int.Int
  
  val function speedlimit : int
end

module Selfdrivingcar__speed___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  
  predicate dynamic_invariant (temp___expr_203: int) (temp___is_init_199: bool) (temp___skip_constant_200: bool) (temp___do_toplevel_201: bool) (temp___do_typ_inv_202: bool) =
    if ((temp___is_init_199 = True) \/
          (Selfdrivingcar__speed.first <= Selfdrivingcar__speed.last)) then
      (((Selfdrivingcar__speed.dynamic_property Selfdrivingcar__speed.first)
          Selfdrivingcar__speed.last)
         temp___expr_203)
    else true
  
  val dynamic_invariant (temp___expr_203: int) (temp___is_init_199: bool) (temp___skip_constant_200: bool) (temp___do_toplevel_201: bool) (temp___do_typ_inv_202: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_203 : int))
                      (temp___is_init_199 : bool))
                     (temp___skip_constant_200 : bool))
                    (temp___do_toplevel_201 : bool))
                   (temp___do_typ_inv_202 : bool)) }
  
  predicate default_initial_assumption (temp___expr_204: int) (temp___skip_top_level_205: bool) =
    true
  
  val default_initial_assumption (temp___expr_204: int) (temp___skip_top_level_205: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_204 : int))
                   (temp___skip_top_level_205 : bool)) }
end

module Selfdrivingcar__gearbox___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  
  predicate dynamic_invariant (temp___expr_175: int) (temp___is_init_171: bool) (temp___skip_constant_172: bool) (temp___do_toplevel_173: bool) (temp___do_typ_inv_174: bool) =
    if ((temp___is_init_171 = True) \/
          (Selfdrivingcar__gearbox.first <= Selfdrivingcar__gearbox.last)) then
      (((Selfdrivingcar__gearbox.dynamic_property
           Selfdrivingcar__gearbox.first)
          Selfdrivingcar__gearbox.last)
         temp___expr_175)
    else true
  
  val dynamic_invariant (temp___expr_175: int) (temp___is_init_171: bool) (temp___skip_constant_172: bool) (temp___do_toplevel_173: bool) (temp___do_typ_inv_174: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_175 : int))
                      (temp___is_init_171 : bool))
                     (temp___skip_constant_172 : bool))
                    (temp___do_toplevel_173 : bool))
                   (temp___do_typ_inv_174 : bool)) }
  
  predicate default_initial_assumption (temp___expr_176: int) (temp___skip_top_level_177: bool) =
    true
  
  val default_initial_assumption (temp___expr_176: int) (temp___skip_top_level_177: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_176 : int))
                   (temp___skip_top_level_177 : bool)) }
end

module Selfdrivingcar__sensor___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  
  predicate dynamic_invariant (temp___expr_182: int) (temp___is_init_178: bool) (temp___skip_constant_179: bool) (temp___do_toplevel_180: bool) (temp___do_typ_inv_181: bool) =
    if ((temp___is_init_178 = True) \/
          (Selfdrivingcar__sensor.first <= Selfdrivingcar__sensor.last)) then
      (((Selfdrivingcar__sensor.dynamic_property Selfdrivingcar__sensor.first)
          Selfdrivingcar__sensor.last)
         temp___expr_182)
    else true
  
  val dynamic_invariant (temp___expr_182: int) (temp___is_init_178: bool) (temp___skip_constant_179: bool) (temp___do_toplevel_180: bool) (temp___do_typ_inv_181: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_182 : int))
                      (temp___is_init_178 : bool))
                     (temp___skip_constant_179 : bool))
                    (temp___do_toplevel_180 : bool))
                   (temp___do_typ_inv_181 : bool)) }
  
  predicate default_initial_assumption (temp___expr_183: int) (temp___skip_top_level_184: bool) =
    true
  
  val default_initial_assumption (temp___expr_183: int) (temp___skip_top_level_184: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_183 : int))
                   (temp___skip_top_level_184 : bool)) }
end

module Selfdrivingcar__ignition___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__ignition as Selfdrivingcar__ignition
  
  predicate dynamic_invariant (temp___expr_189: int) (temp___is_init_185: bool) (temp___skip_constant_186: bool) (temp___do_toplevel_187: bool) (temp___do_typ_inv_188: bool) =
    if ((temp___is_init_185 = True) \/
          (Selfdrivingcar__ignition.first <= Selfdrivingcar__ignition.last)) then
      (((Selfdrivingcar__ignition.dynamic_property
           Selfdrivingcar__ignition.first)
          Selfdrivingcar__ignition.last)
         temp___expr_189)
    else true
  
  val dynamic_invariant (temp___expr_189: int) (temp___is_init_185: bool) (temp___skip_constant_186: bool) (temp___do_toplevel_187: bool) (temp___do_typ_inv_188: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_189 : int))
                      (temp___is_init_185 : bool))
                     (temp___skip_constant_186 : bool))
                    (temp___do_toplevel_187 : bool))
                   (temp___do_typ_inv_188 : bool)) }
  
  predicate default_initial_assumption (temp___expr_190: int) (temp___skip_top_level_191: bool) =
    true
  
  val default_initial_assumption (temp___expr_190: int) (temp___skip_top_level_191: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_190 : int))
                   (temp___skip_top_level_191 : bool)) }
end

module Selfdrivingcar__diagnostics___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  
  predicate dynamic_invariant (temp___expr_196: int) (temp___is_init_192: bool) (temp___skip_constant_193: bool) (temp___do_toplevel_194: bool) (temp___do_typ_inv_195: bool) =
    if ((temp___is_init_192 = True) \/
          (Selfdrivingcar__diagnostics.first
             <= Selfdrivingcar__diagnostics.last)) then
      (((Selfdrivingcar__diagnostics.dynamic_property
           Selfdrivingcar__diagnostics.first)
          Selfdrivingcar__diagnostics.last)
         temp___expr_196)
    else true
  
  val dynamic_invariant (temp___expr_196: int) (temp___is_init_192: bool) (temp___skip_constant_193: bool) (temp___do_toplevel_194: bool) (temp___do_typ_inv_195: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_196 : int))
                      (temp___is_init_192 : bool))
                     (temp___skip_constant_193 : bool))
                    (temp___do_toplevel_194 : bool))
                   (temp___do_typ_inv_195 : bool)) }
  
  predicate default_initial_assumption (temp___expr_197: int) (temp___skip_top_level_198: bool) =
    true
  
  val default_initial_assumption (temp___expr_197: int) (temp___skip_top_level_198: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_197 : int))
                   (temp___skip_top_level_198 : bool)) }
end

module Selfdrivingcar__batterypercentage___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  
  predicate dynamic_invariant (temp___expr_210: int) (temp___is_init_206: bool) (temp___skip_constant_207: bool) (temp___do_toplevel_208: bool) (temp___do_typ_inv_209: bool) =
    if ((temp___is_init_206 = True) \/
          (Selfdrivingcar__batterypercentage.first
             <= Selfdrivingcar__batterypercentage.last)) then
      (((Selfdrivingcar__batterypercentage.dynamic_property
           Selfdrivingcar__batterypercentage.first)
          Selfdrivingcar__batterypercentage.last)
         temp___expr_210)
    else true
  
  val dynamic_invariant (temp___expr_210: int) (temp___is_init_206: bool) (temp___skip_constant_207: bool) (temp___do_toplevel_208: bool) (temp___do_typ_inv_209: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_210 : int))
                      (temp___is_init_206 : bool))
                     (temp___skip_constant_207 : bool))
                    (temp___do_toplevel_208 : bool))
                   (temp___do_typ_inv_209 : bool)) }
  
  predicate default_initial_assumption (temp___expr_211: int) (temp___skip_top_level_212: bool) =
    true
  
  val default_initial_assumption (temp___expr_211: int) (temp___skip_top_level_212: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_211 : int))
                   (temp___skip_top_level_212 : bool)) }
end

module Selfdrivingcar__mycar___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Selfdrivingcar__applyacceleratorpedal__speedlimit___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Selfdrivingcar__applyacceleratorpedal__subprogram_def
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use _gnatprove_standard.Main as Main
  use _gnatprove_standard.Boolean as Boolean
  use Selfdrivingcar__mycar as Selfdrivingcar__mycar
  use Selfdrivingcar__car as Selfdrivingcar__car
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__invariant as Selfdrivingcar__invariant
  use Selfdrivingcar__invariant___axiom as Selfdrivingcar__invariant___axiom
  use Selfdrivingcar__applyacceleratorpedal__speedlimit as Selfdrivingcar__applyacceleratorpedal__speedlimit
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  use Selfdrivingcar__sensor__rep as Selfdrivingcar__sensor__rep
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  use Selfdrivingcar__speed___axiom as Selfdrivingcar__speed___axiom
  use Selfdrivingcar__speed__rep as Selfdrivingcar__speed__rep
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  use Selfdrivingcar__batterypercentage__rep as Selfdrivingcar__batterypercentage__rep
  use Selfdrivingcar__gearbox___axiom as Selfdrivingcar__gearbox___axiom
  use Selfdrivingcar__sensor___axiom as Selfdrivingcar__sensor___axiom
  use Selfdrivingcar__ignition___axiom as Selfdrivingcar__ignition___axiom
  use Selfdrivingcar__diagnostics___axiom as Selfdrivingcar__diagnostics___axiom
  use Selfdrivingcar__speed___axiom as Selfdrivingcar__speed___axiom
  use Selfdrivingcar__batterypercentage___axiom as Selfdrivingcar__batterypercentage___axiom
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__mycar___axiom as Selfdrivingcar__mycar___axiom
  use Selfdrivingcar__invariant___axiom as Selfdrivingcar__invariant___axiom
  use Selfdrivingcar__applyacceleratorpedal__speedlimit___axiom as Selfdrivingcar__applyacceleratorpedal__speedlimit___axiom
  
  let def (__void_param : unit)
    requires { [#"selfdrivingcar.ads" 55 0 0] true }
    ensures { [#"selfdrivingcar.ads" 55 0 0]
              [#"selfdrivingcar.ads" 59 0 0]
              [@GP_Reason:VC_POSTCONDITION]
              [@GP_Sloc:selfdrivingcar.ads:59:16]
              [@comment:       Post => Invariant and (myCar.currentSpeed <= speedLimit);                ^ selfdrivingcar.ads:59:16:VC_POSTCONDITION]
              [@model_vc_post]
              [@GP_Id:2]
              [@GP_Shape:pragargs__and]
              (([@GP_Pretty_Ada:1073]
                [@GP_Sloc:selfdrivingcar.ads:59:16]
                ((epsilon temp___result_245: bool.
                    ((temp___result_245
                        = (Selfdrivingcar__invariant.invariant__
                             (Selfdrivingcar__car.__split_fields__content
                                 Selfdrivingcar__mycar.mycar__split_fields))) /\
                       ((Selfdrivingcar__invariant.invariant____function_guard
                           temp___result_245)
                          (Selfdrivingcar__car.__split_fields__content
                              Selfdrivingcar__mycar.mycar__split_fields))))
                   = True)) /\
                 ([@GP_Pretty_Ada:1079]
                  [@GP_Sloc:selfdrivingcar.ads:59:30]
                  ((Selfdrivingcar__speed__rep.to_rep
                      ((Selfdrivingcar__car.__split_fields
                           { Selfdrivingcar__car.__split_fields =
                               (Selfdrivingcar__car.__split_fields__content
                                   Selfdrivingcar__mycar.mycar__split_fields) }).
                         Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                     <= Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit))) }
  = [@vc:divergent]
    (([@GNAT-comment:Assume dynamic invariants of inputs of the subprogram selfdrivingcar.ads:55]
      ());
     assume {
       ((((Selfdrivingcar__car___axiom.dynamic_invariant
             { Selfdrivingcar__car.__split_fields =
                 (Selfdrivingcar__car.__split_fields__content
                     Selfdrivingcar__mycar.mycar__split_fields) })
            True)
           False)
          True)
         True };
     assume {
       ((((Selfdrivingcar__speed___axiom.dynamic_invariant
             Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit)
            True)
           False)
          True)
         True };
     ([@GNAT-comment:Assume moved pointers in outputs of the subprogram selfdrivingcar.ads:55]
      ());
     ([@GNAT-comment:Check for RTE in the Pre of the subprogram selfdrivingcar.ads:55]
      ());
     (begin
        ensures { true }
        let _ =
          let _ =
            (Boolean.andb
               ((Boolean.andb
                   (Selfdrivingcar__invariant___axiom.invariant__ ()))
                  (((Selfdrivingcar__speed__rep.to_rep
                       ((Selfdrivingcar__car.__split_fields
                            { Selfdrivingcar__car.__split_fields =
                                (Selfdrivingcar__car.__split_fields__content
                                    Selfdrivingcar__mycar.mycar__split_fields) }).
                          Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                      + (1 : int))
                     < Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit)))
              ((Selfdrivingcar__sensor__rep.to_rep
                  ((Selfdrivingcar__car.__split_fields
                       { Selfdrivingcar__car.__split_fields =
                           (Selfdrivingcar__car.__split_fields__content
                               Selfdrivingcar__mycar.mycar__split_fields) }).
                     Selfdrivingcar__car.rec__selfdrivingcar__car__objectscanner))
                 = (1 : int)) in
          () in
        ()
      end);
     ([@GNAT-comment:Assume Pre of the subprogram selfdrivingcar.ads:55] ());
     assume {
       ((([@GP_Pretty_Ada:1055]
          ((epsilon temp___result_244: bool.
              ((temp___result_244
                  = (Selfdrivingcar__invariant.invariant__
                       (Selfdrivingcar__car.__split_fields__content
                           Selfdrivingcar__mycar.mycar__split_fields))) /\
                 ((Selfdrivingcar__invariant.invariant____function_guard
                     temp___result_244)
                    (Selfdrivingcar__car.__split_fields__content
                        Selfdrivingcar__mycar.mycar__split_fields))))
             = True)) /\
           ([@GP_Pretty_Ada:1063]
            (((Selfdrivingcar__speed__rep.to_rep
                 ((Selfdrivingcar__car.__split_fields
                      { Selfdrivingcar__car.__split_fields =
                          (Selfdrivingcar__car.__split_fields__content
                              Selfdrivingcar__mycar.mycar__split_fields) }).
                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                + (1 : int))
               < Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit))) /\
          ([@GP_Pretty_Ada:1069]
           ((Selfdrivingcar__sensor__rep.to_rep
               ((Selfdrivingcar__car.__split_fields
                    { Selfdrivingcar__car.__split_fields =
                        (Selfdrivingcar__car.__split_fields__content
                            Selfdrivingcar__mycar.mycar__split_fields) }).
                  Selfdrivingcar__car.rec__selfdrivingcar__car__objectscanner))
              = (1 : int)))) };
     (try
        ([@GP_Sloc:selfdrivingcar.adb:20:7] [#"selfdrivingcar.adb" 20 0 0] ());
        ([@GP_Sloc:selfdrivingcar.adb:20:29]
         [#"selfdrivingcar.adb" 20 0 0] ());
        ([@GP_Sloc:selfdrivingcar.adb:20:26]
         [#"selfdrivingcar.adb" 20 0 0]
         (let temp___240 =
            let temp___239 =
              { Selfdrivingcar__car.__split_fields =
                  (Selfdrivingcar__car.__split_fields__content
                      Selfdrivingcar__mycar.mycar__split_fields) } in
            ([#"selfdrivingcar.adb" 20 0 0]
             (begin
                ensures { true }
                let _ =
                  let _ =
                    (Selfdrivingcar__car.__split_fields temp___239).Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed in
                  () in
                ()
              end));
            ({ temp___239 with
               Selfdrivingcar__car.__split_fields =
                 ({ (Selfdrivingcar__car.__split_fields temp___239) with
                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed =
                      (Selfdrivingcar__speed__rep.of_rep
                         ([#"selfdrivingcar.adb" 20 0 0]
                          [@vc:annotation]
                          [@GP_Shape:mycar_assign__add]
                          [@GP_Reason:VC_RANGE_CHECK]
                          [@comment:      myCar.currentSpeed := myCar.currentSpeed + 1;                                                ^ selfdrivingcar.adb:20:48:VC_RANGE_CHECK]
                          [@GP_Id:1]
                          [@GP_Sloc:selfdrivingcar.adb:20:48]
                          (Selfdrivingcar__speed.range_check_
                             ((Selfdrivingcar__speed__rep.to_rep
                                 ((Selfdrivingcar__car.__split_fields
                                      { Selfdrivingcar__car.__split_fields =
                                          (Selfdrivingcar__car.__split_fields__content
                                              Selfdrivingcar__mycar.mycar__split_fields) }).
                                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                                + (1 : int))))) }) }) in
          Selfdrivingcar__mycar.mycar__split_fields.Selfdrivingcar__car.__split_fields__content <-
            (Selfdrivingcar__car.__split_fields temp___240)));
        ([@GP_Sloc:selfdrivingcar.adb:21:11]
         [#"selfdrivingcar.adb" 21 0 0] ());
        ([@GP_Sloc:selfdrivingcar.adb:21:7]
         [#"selfdrivingcar.adb" 21 0 0]
         (if (([#"selfdrivingcar.adb" 21 0 0]
               [#"selfdrivingcar.adb" 21 0 0]
               (([@branch_id=870] Main.spark__branch).bool__content <-
                  ((Selfdrivingcar__batterypercentage__rep.to_rep
                      ((Selfdrivingcar__car.__split_fields
                           { Selfdrivingcar__car.__split_fields =
                               (Selfdrivingcar__car.__split_fields__content
                                   Selfdrivingcar__mycar.mycar__split_fields) }).
                         Selfdrivingcar__car.rec__selfdrivingcar__car__batterycharge))
                     < (15 : int))));
              (([@branch_id=870] Main.spark__branch).bool__content)) then
            (([@GP_Sloc:selfdrivingcar.adb:24:10]
              [#"selfdrivingcar.adb" 24 0 0] ());
             ([@GP_Sloc:selfdrivingcar.adb:24:32]
              [#"selfdrivingcar.adb" 24 0 0] ());
             ([@GP_Sloc:selfdrivingcar.adb:24:29]
              [#"selfdrivingcar.adb" 24 0 0]
              (let temp___243 =
                 let temp___242 =
                   { Selfdrivingcar__car.__split_fields =
                       (Selfdrivingcar__car.__split_fields__content
                           Selfdrivingcar__mycar.mycar__split_fields) } in
                 ([#"selfdrivingcar.adb" 24 0 0]
                  (begin
                     ensures { true }
                     let _ =
                       let _ =
                         (Selfdrivingcar__car.__split_fields temp___242).
                           Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed in
                       () in
                     ()
                   end));
                 ({ temp___242 with
                    Selfdrivingcar__car.__split_fields =
                      ({ (Selfdrivingcar__car.__split_fields temp___242) with
                         Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed =
                           (Selfdrivingcar__speed__rep.of_rep
                              (Selfdrivingcar__speed__rep.to_rep
                                 ((Selfdrivingcar__car.__split_fields
                                      { Selfdrivingcar__car.__split_fields =
                                          (Selfdrivingcar__car.__split_fields__content
                                              Selfdrivingcar__mycar.mycar__split_fields) }).
                                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))) }) }) in
               [#"selfdrivingcar.adb" 24 0 0]
               (Selfdrivingcar__mycar.mycar__split_fields.Selfdrivingcar__car.__split_fields__content <-
                  (Selfdrivingcar__car.__split_fields temp___243)))))
          else ()));
        (raise Return__exc)
      with Return__exc -> ()
      end);
     (begin
        ensures { true }
        let _ =
          let _ =
            (Boolean.andb (Selfdrivingcar__invariant___axiom.invariant__ ()))
              ((Selfdrivingcar__speed__rep.to_rep
                  ((Selfdrivingcar__car.__split_fields
                       { Selfdrivingcar__car.__split_fields =
                           (Selfdrivingcar__car.__split_fields__content
                               Selfdrivingcar__mycar.mycar__split_fields) }).
                     Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                 <= Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit) in
          () in
        ()
      end))
end
