module Selfdrivingcar__gearbox
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type gearbox
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (2 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = gearbox,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type gearbox__ref = { mutable gearbox__content : gearbox }
  
  function gearbox__ref_gearbox__content__projection (a: gearbox__ref) : gearbox =
    a.gearbox__content
  
  meta "model_projection" function gearbox__ref_gearbox__content__projection
  
  meta "inline:no" function gearbox__ref_gearbox__content__projection
  
  val gearbox__havoc (x: gearbox__ref) : unit
    writes { x }
end

module Selfdrivingcar__gearbox__rep
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__gearbox.gearbox,
    predicate in_range = Selfdrivingcar__gearbox.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__sensor
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type sensor
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = sensor,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type sensor__ref = { mutable sensor__content : sensor }
  
  function sensor__ref_sensor__content__projection (a: sensor__ref) : sensor =
    a.sensor__content
  
  meta "model_projection" function sensor__ref_sensor__content__projection
  
  meta "inline:no" function sensor__ref_sensor__content__projection
  
  val sensor__havoc (x: sensor__ref) : unit
    writes { x }
end

module Selfdrivingcar__sensor__rep
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__sensor.sensor,
    predicate in_range = Selfdrivingcar__sensor.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__ignition
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type ignition
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = ignition,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type ignition__ref = { mutable ignition__content : ignition }
  
  function ignition__ref_ignition__content__projection (a: ignition__ref) : ignition =
    a.ignition__content
  
  meta "model_projection" function ignition__ref_ignition__content__projection
  
  meta "inline:no" function ignition__ref_ignition__content__projection
  
  val ignition__havoc (x: ignition__ref) : unit
    writes { x }
end

module Selfdrivingcar__ignition__rep
  use Selfdrivingcar__ignition as Selfdrivingcar__ignition
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__ignition.ignition,
    predicate in_range = Selfdrivingcar__ignition.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__diagnostics
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type diagnostics
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (1 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = diagnostics,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type diagnostics__ref = { mutable diagnostics__content : diagnostics }
  
  function diagnostics__ref_diagnostics__content__projection (a: diagnostics__ref) : diagnostics =
    a.diagnostics__content
  
  meta "model_projection" function diagnostics__ref_diagnostics__content__projection
  
  meta "inline:no" function diagnostics__ref_diagnostics__content__projection
  
  val diagnostics__havoc (x: diagnostics__ref) : unit
    writes { x }
end

module Selfdrivingcar__diagnostics__rep
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  use _gnatprove_standard.Main
  use int.Int
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__diagnostics.diagnostics,
    predicate in_range = Selfdrivingcar__diagnostics.in_range
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__speed
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type speed = <range 0 70>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (70 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = speed,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type speed__ref = { mutable speed__content : speed }
  
  function speed__ref_speed__content__projection (a: speed__ref) : speed =
    a.speed__content
  
  meta "model_projection" function speed__ref_speed__content__projection
  
  meta "inline:no" function speed__ref_speed__content__projection
  
  val speed__havoc (x: speed__ref) : unit
    writes { x }
end

module Selfdrivingcar__speed__rep
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Selfdrivingcar__speed.speed) : int =
    Selfdrivingcar__speed.speed'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__speed.speed,
    predicate in_range = Selfdrivingcar__speed.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__batterypercentage
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type batterypercentage = <range 0 100>
  
  val function first : int
    ensures { result = (0 : int) }
  
  val function last : int
    ensures { result = (100 : int) }
  
  predicate in_range (x: int) = ((first <= x) /\ (x <= last))
  
  val in_range (x: int) : bool
    ensures { result <-> (in_range (x : int)) }
  
  clone export ada__model.Static_Discrete with
    axiom .,
    type t = batterypercentage,
    function first = first,
    function last = last,
    predicate in_range = in_range
  
  type batterypercentage__ref = {
                               mutable batterypercentage__content :
                                 batterypercentage
                               }
  
  function batterypercentage__ref_batterypercentage__content__projection (a: batterypercentage__ref) : batterypercentage =
    a.batterypercentage__content
  
  meta "model_projection" function batterypercentage__ref_batterypercentage__content__projection
  
  meta "inline:no" function batterypercentage__ref_batterypercentage__content__projection
  
  val batterypercentage__havoc (x: batterypercentage__ref) : unit
    writes { x }
end

module Selfdrivingcar__batterypercentage__rep
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  use _gnatprove_standard.Main
  use int.Int
  
  function to_rep (x: Selfdrivingcar__batterypercentage.batterypercentage) : int =
    Selfdrivingcar__batterypercentage.batterypercentage'int x
  
  clone export ada__model.Rep_Proj_Int with
    axiom .,
    type t = Selfdrivingcar__batterypercentage.batterypercentage,
    predicate in_range = Selfdrivingcar__batterypercentage.in_range,
    function to_rep = to_rep
  
  meta "model_projection" function to_rep
  
  meta "inline:no" function to_rep
end

module Selfdrivingcar__car__rep
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  use Selfdrivingcar__gearbox__rep as Selfdrivingcar__gearbox__rep
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  use Selfdrivingcar__sensor__rep as Selfdrivingcar__sensor__rep
  use Selfdrivingcar__ignition as Selfdrivingcar__ignition
  use Selfdrivingcar__ignition__rep as Selfdrivingcar__ignition__rep
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  use Selfdrivingcar__diagnostics__rep as Selfdrivingcar__diagnostics__rep
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  use Selfdrivingcar__speed__rep as Selfdrivingcar__speed__rep
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  use Selfdrivingcar__batterypercentage__rep as Selfdrivingcar__batterypercentage__rep
  
  type __split_fields = {
                       rec__selfdrivingcar__car__gearengaged :
                         Selfdrivingcar__gearbox.gearbox;
                       rec__selfdrivingcar__car__objectscanner :
                         Selfdrivingcar__sensor.sensor;
                       rec__selfdrivingcar__car__status :
                         Selfdrivingcar__ignition.ignition;
                       rec__selfdrivingcar__car__diagnosticmode :
                         Selfdrivingcar__diagnostics.diagnostics;
                       rec__selfdrivingcar__car__currentspeed :
                         Selfdrivingcar__speed.speed;
                       rec__selfdrivingcar__car__batterycharge :
                         Selfdrivingcar__batterypercentage.batterypercentage
                       }
  
  function __split_fields_rec__selfdrivingcar__car__gearengaged__projection (a: __split_fields) : 
    Selfdrivingcar__gearbox.gearbox =
    a.rec__selfdrivingcar__car__gearengaged
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__gearengaged__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__gearengaged__projection
  
  function __split_fields_rec__selfdrivingcar__car__objectscanner__projection (a: __split_fields) : 
    Selfdrivingcar__sensor.sensor =
    a.rec__selfdrivingcar__car__objectscanner
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__objectscanner__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__objectscanner__projection
  
  function __split_fields_rec__selfdrivingcar__car__status__projection (a: __split_fields) : 
    Selfdrivingcar__ignition.ignition =
    a.rec__selfdrivingcar__car__status
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__status__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__status__projection
  
  function __split_fields_rec__selfdrivingcar__car__diagnosticmode__projection (a: __split_fields) : 
    Selfdrivingcar__diagnostics.diagnostics =
    a.rec__selfdrivingcar__car__diagnosticmode
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__diagnosticmode__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__diagnosticmode__projection
  
  function __split_fields_rec__selfdrivingcar__car__currentspeed__projection (a: __split_fields) : 
    Selfdrivingcar__speed.speed =
    a.rec__selfdrivingcar__car__currentspeed
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__currentspeed__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__currentspeed__projection
  
  function __split_fields_rec__selfdrivingcar__car__batterycharge__projection (a: __split_fields) : 
    Selfdrivingcar__batterypercentage.batterypercentage =
    a.rec__selfdrivingcar__car__batterycharge
  
  meta "model_projection" function __split_fields_rec__selfdrivingcar__car__batterycharge__projection
  
  meta "inline:no" function __split_fields_rec__selfdrivingcar__car__batterycharge__projection
  
  type __split_fields__ref = {
                            mutable __split_fields__content : __split_fields
                            }
  
  function __split_fields__ref___split_fields__content__projection (a: __split_fields__ref) : __split_fields =
    __split_fields__content a
  
  meta "model_projection" function __split_fields__ref___split_fields__content__projection
  
  meta "inline:no" function __split_fields__ref___split_fields__content__projection
  
  val __split_fields__havoc (x: __split_fields__ref) : unit
    writes { x }
  
  type __rep = { __split_fields : __split_fields }
  
  function __rep___split_fields__projection (a: __rep) : __split_fields =
    __split_fields a
  
  meta "model_projection" function __rep___split_fields__projection
  
  meta "inline:no" function __rep___split_fields__projection
  
  function to_base (a: __rep) : __rep = a
  
  val to_base (a: __rep) : __rep
    ensures { result = (to_base (a : __rep)) }
  
  function of_base (a: __rep) : __rep = a
  
  val of_base (a: __rep) : __rep
    ensures { result = (of_base (a : __rep)) }
  
  predicate selfdrivingcar__car__gearengaged__pred (a: __rep) = true
  
  val selfdrivingcar__car__gearengaged__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__gearengaged__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__gearengaged_ (a: __rep) : Selfdrivingcar__gearbox.gearbox
    requires { selfdrivingcar__car__gearengaged__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__gearengaged)) }
  
  predicate selfdrivingcar__car__objectscanner__pred (a: __rep) = true
  
  val selfdrivingcar__car__objectscanner__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__objectscanner__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__objectscanner_ (a: __rep) : Selfdrivingcar__sensor.sensor
    requires { selfdrivingcar__car__objectscanner__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__objectscanner)) }
  
  predicate selfdrivingcar__car__status__pred (a: __rep) = true
  
  val selfdrivingcar__car__status__pred (a: __rep) : bool
    ensures { result <-> (selfdrivingcar__car__status__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__status_ (a: __rep) : Selfdrivingcar__ignition.ignition
    requires { selfdrivingcar__car__status__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__status)) }
  
  predicate selfdrivingcar__car__diagnosticmode__pred (a: __rep) = true
  
  val selfdrivingcar__car__diagnosticmode__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__diagnosticmode__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__diagnosticmode_ (a: __rep) : Selfdrivingcar__diagnostics.diagnostics
    requires { selfdrivingcar__car__diagnosticmode__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__diagnosticmode)) }
  
  predicate selfdrivingcar__car__currentspeed__pred (a: __rep) = true
  
  val selfdrivingcar__car__currentspeed__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__currentspeed__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__currentspeed_ (a: __rep) : Selfdrivingcar__speed.speed
    requires { selfdrivingcar__car__currentspeed__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__currentspeed)) }
  
  predicate selfdrivingcar__car__batterycharge__pred (a: __rep) = true
  
  val selfdrivingcar__car__batterycharge__pred (a: __rep) : bool
    ensures { result
                <->
                (selfdrivingcar__car__batterycharge__pred (a : __rep)) }
  
  val rec__selfdrivingcar__car__batterycharge_ (a: __rep) : Selfdrivingcar__batterypercentage.batterypercentage
    requires { selfdrivingcar__car__batterycharge__pred a }
    ensures { (result
                 = ((__split_fields a).rec__selfdrivingcar__car__batterycharge)) }
  
  function bool_eq (a: __rep) (b: __rep) : bool =
    if ((((Selfdrivingcar__gearbox__rep.to_rep
             ((__split_fields a).rec__selfdrivingcar__car__gearengaged))
            = (Selfdrivingcar__gearbox__rep.to_rep
                 ((__split_fields b).rec__selfdrivingcar__car__gearengaged))) /\
           ((Selfdrivingcar__sensor__rep.to_rep
               ((__split_fields a).rec__selfdrivingcar__car__objectscanner))
              = (Selfdrivingcar__sensor__rep.to_rep
                   ((__split_fields b).rec__selfdrivingcar__car__objectscanner)))) /\
          ((((Selfdrivingcar__ignition__rep.to_rep
                ((__split_fields a).rec__selfdrivingcar__car__status))
               = (Selfdrivingcar__ignition__rep.to_rep
                    ((__split_fields b).rec__selfdrivingcar__car__status))) /\
              ((Selfdrivingcar__diagnostics__rep.to_rep
                  ((__split_fields a).rec__selfdrivingcar__car__diagnosticmode))
                 = (Selfdrivingcar__diagnostics__rep.to_rep
                      ((__split_fields b).rec__selfdrivingcar__car__diagnosticmode)))) /\
             (((Selfdrivingcar__speed__rep.to_rep
                  ((__split_fields a).rec__selfdrivingcar__car__currentspeed))
                 = (Selfdrivingcar__speed__rep.to_rep
                      ((__split_fields b).rec__selfdrivingcar__car__currentspeed))) /\
                ((Selfdrivingcar__batterypercentage__rep.to_rep
                    ((__split_fields a).rec__selfdrivingcar__car__batterycharge))
                   = (Selfdrivingcar__batterypercentage__rep.to_rep
                        ((__split_fields b).rec__selfdrivingcar__car__batterycharge)))))) then
      True
    else False
  
  val bool_eq (a: __rep) (b: __rep) : bool
    ensures { result = ((bool_eq (a : __rep)) (b : __rep)) }
end

module Selfdrivingcar__car
  use export Selfdrivingcar__car__rep
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  
  type car = __rep
  
  val function value__size : int
  
  val function object__size : int
  
  val function alignment : int
  
  axiom value__size_axiom: (value__size >= (0 : int))
  
  axiom object__size_axiom: (object__size >= (0 : int))
  
  axiom alignment_axiom: (alignment >= (0 : int))
  
  val function selfdrivingcar__car__gearengaged__first__bit : int
  
  val function selfdrivingcar__car__gearengaged__last__bit : int
  
  val function selfdrivingcar__car__gearengaged__position : int
  
  axiom selfdrivingcar__car__gearengaged__first__bit_axiom:
    (selfdrivingcar__car__gearengaged__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__gearengaged__last__bit_axiom:
    (selfdrivingcar__car__gearengaged__last__bit
       > selfdrivingcar__car__gearengaged__first__bit)
  
  axiom selfdrivingcar__car__gearengaged__position_axiom:
    (selfdrivingcar__car__gearengaged__position >= (0 : int))
  
  val function selfdrivingcar__car__objectscanner__first__bit : int
  
  val function selfdrivingcar__car__objectscanner__last__bit : int
  
  val function selfdrivingcar__car__objectscanner__position : int
  
  axiom selfdrivingcar__car__objectscanner__first__bit_axiom:
    (selfdrivingcar__car__objectscanner__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__objectscanner__last__bit_axiom:
    (selfdrivingcar__car__objectscanner__last__bit
       > selfdrivingcar__car__objectscanner__first__bit)
  
  axiom selfdrivingcar__car__objectscanner__position_axiom:
    (selfdrivingcar__car__objectscanner__position >= (0 : int))
  
  val function selfdrivingcar__car__status__first__bit : int
  
  val function selfdrivingcar__car__status__last__bit : int
  
  val function selfdrivingcar__car__status__position : int
  
  axiom selfdrivingcar__car__status__first__bit_axiom:
    (selfdrivingcar__car__status__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__status__last__bit_axiom:
    (selfdrivingcar__car__status__last__bit
       > selfdrivingcar__car__status__first__bit)
  
  axiom selfdrivingcar__car__status__position_axiom:
    (selfdrivingcar__car__status__position >= (0 : int))
  
  val function selfdrivingcar__car__diagnosticmode__first__bit : int
  
  val function selfdrivingcar__car__diagnosticmode__last__bit : int
  
  val function selfdrivingcar__car__diagnosticmode__position : int
  
  axiom selfdrivingcar__car__diagnosticmode__first__bit_axiom:
    (selfdrivingcar__car__diagnosticmode__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__diagnosticmode__last__bit_axiom:
    (selfdrivingcar__car__diagnosticmode__last__bit
       > selfdrivingcar__car__diagnosticmode__first__bit)
  
  axiom selfdrivingcar__car__diagnosticmode__position_axiom:
    (selfdrivingcar__car__diagnosticmode__position >= (0 : int))
  
  val function selfdrivingcar__car__currentspeed__first__bit : int
  
  val function selfdrivingcar__car__currentspeed__last__bit : int
  
  val function selfdrivingcar__car__currentspeed__position : int
  
  axiom selfdrivingcar__car__currentspeed__first__bit_axiom:
    (selfdrivingcar__car__currentspeed__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__currentspeed__last__bit_axiom:
    (selfdrivingcar__car__currentspeed__last__bit
       > selfdrivingcar__car__currentspeed__first__bit)
  
  axiom selfdrivingcar__car__currentspeed__position_axiom:
    (selfdrivingcar__car__currentspeed__position >= (0 : int))
  
  val function selfdrivingcar__car__batterycharge__first__bit : int
  
  val function selfdrivingcar__car__batterycharge__last__bit : int
  
  val function selfdrivingcar__car__batterycharge__position : int
  
  axiom selfdrivingcar__car__batterycharge__first__bit_axiom:
    (selfdrivingcar__car__batterycharge__first__bit >= (0 : int))
  
  axiom selfdrivingcar__car__batterycharge__last__bit_axiom:
    (selfdrivingcar__car__batterycharge__last__bit
       > selfdrivingcar__car__batterycharge__first__bit)
  
  axiom selfdrivingcar__car__batterycharge__position_axiom:
    (selfdrivingcar__car__batterycharge__position >= (0 : int))
  
  val function user_eq (a: car) (b: car) : bool
  
  val function dummy : car
  
  type car__ref = { mutable car__content : car }
  
  function car__ref_car__content__projection (a: car__ref) : car =
    a.car__content
  
  meta "model_projection" function car__ref_car__content__projection
  
  meta "inline:no" function car__ref_car__content__projection
  
  val car__havoc (x: car__ref) : unit
    writes { x }
end

module Selfdrivingcar__mycar
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  val mycar__split_fields : Selfdrivingcar__car.__split_fields__ref
end

module Selfdrivingcar__car___axiom
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  predicate dynamic_invariant (temp___expr_208: Selfdrivingcar__car.car) (temp___is_init_204: bool) (temp___skip_constant_205: bool) (temp___do_toplevel_206: bool) (temp___do_typ_inv_207: bool) =
    true
  
  val dynamic_invariant (temp___expr_208: Selfdrivingcar__car.car) (temp___is_init_204: bool) (temp___skip_constant_205: bool) (temp___do_toplevel_206: bool) (temp___do_typ_inv_207: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant
                       (temp___expr_208 : Selfdrivingcar__car.car))
                      (temp___is_init_204 : bool))
                     (temp___skip_constant_205 : bool))
                    (temp___do_toplevel_206 : bool))
                   (temp___do_typ_inv_207 : bool)) }
  
  predicate default_initial_assumption (temp___expr_209: Selfdrivingcar__car.car) (temp___skip_top_level_210: bool) =
    true
  
  val default_initial_assumption (temp___expr_209: Selfdrivingcar__car.car) (temp___skip_top_level_210: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption
                    (temp___expr_209 : Selfdrivingcar__car.car))
                   (temp___skip_top_level_210 : bool)) }
end

module Selfdrivingcar__invariant
  use _gnatprove_standard.Main
  use int.Int
  use Selfdrivingcar__car as Selfdrivingcar__car
  
  val function invariant__ (Selfdrivingcar__mycar___mycar__split_fields___: 
    Selfdrivingcar__car.__split_fields) : bool
  
  val predicate invariant____function_guard (temp___result_161: bool) (Selfdrivingcar__mycar___mycar__split_fields___: 
    Selfdrivingcar__car.__split_fields)
end

module Selfdrivingcar__invariant___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__mycar as Selfdrivingcar__mycar
  use Selfdrivingcar__car as Selfdrivingcar__car
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__invariant as Selfdrivingcar__invariant
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  use Selfdrivingcar__diagnostics__rep as Selfdrivingcar__diagnostics__rep
  
  val invariant__ (__void_param: unit) : bool
    reads { Selfdrivingcar__mycar.mycar__split_fields }
    requires { true }
    writes {  }
    ensures { (((result
                   = (Selfdrivingcar__invariant.invariant__
                        (Selfdrivingcar__car.__split_fields__content
                            Selfdrivingcar__mycar.mycar__split_fields))) /\
                  ((Selfdrivingcar__invariant.invariant____function_guard
                      result)
                     (Selfdrivingcar__car.__split_fields__content
                         Selfdrivingcar__mycar.mycar__split_fields))) /\
                 (result
                    = ((Selfdrivingcar__diagnostics__rep.to_rep
                          ((Selfdrivingcar__car.__split_fields
                               { Selfdrivingcar__car.__split_fields =
                                   (Selfdrivingcar__car.__split_fields__content
                                       Selfdrivingcar__mycar.mycar__split_fields) }).
                             Selfdrivingcar__car.rec__selfdrivingcar__car__diagnosticmode))
                         <> (0 : int)))) }
  
  axiom invariant____post_axiom:
    forall Selfdrivingcar__mycar___mycar__split_fields___ : Selfdrivingcar__car.__split_fields
          [Selfdrivingcar__invariant.invariant__
             Selfdrivingcar__mycar___mycar__split_fields___].
      ((((((Selfdrivingcar__car___axiom.dynamic_invariant
              { Selfdrivingcar__car.__split_fields =
                  Selfdrivingcar__mycar___mycar__split_fields___ })
             True)
            True)
           True)
          True) ->
         (let result =
            Selfdrivingcar__invariant.invariant__
              Selfdrivingcar__mycar___mycar__split_fields___ in
          if ((Selfdrivingcar__invariant.invariant____function_guard result)
                Selfdrivingcar__mycar___mycar__split_fields___) then
            ((true /\ true) /\ true)
          else true))
  
  axiom invariant____def_axiom:
    forall Selfdrivingcar__mycar___mycar__split_fields___ : Selfdrivingcar__car.__split_fields
          [Selfdrivingcar__invariant.invariant__
             Selfdrivingcar__mycar___mycar__split_fields___].
      ((Selfdrivingcar__invariant.invariant__
          Selfdrivingcar__mycar___mycar__split_fields___)
         = ((Selfdrivingcar__diagnostics__rep.to_rep
               ((Selfdrivingcar__car.__split_fields
                    { Selfdrivingcar__car.__split_fields =
                        Selfdrivingcar__mycar___mycar__split_fields___ }).
                  Selfdrivingcar__car.rec__selfdrivingcar__car__diagnosticmode))
              <> (0 : int)))
end

module Selfdrivingcar__applyacceleratorpedal__speedlimit
  use _gnatprove_standard.Main
  use int.Int
  
  val function speedlimit : int
end

module Selfdrivingcar__speed___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  
  predicate dynamic_invariant (temp___expr_194: int) (temp___is_init_190: bool) (temp___skip_constant_191: bool) (temp___do_toplevel_192: bool) (temp___do_typ_inv_193: bool) =
    if ((temp___is_init_190 = True) \/
          (Selfdrivingcar__speed.first <= Selfdrivingcar__speed.last)) then
      (((Selfdrivingcar__speed.dynamic_property Selfdrivingcar__speed.first)
          Selfdrivingcar__speed.last)
         temp___expr_194)
    else true
  
  val dynamic_invariant (temp___expr_194: int) (temp___is_init_190: bool) (temp___skip_constant_191: bool) (temp___do_toplevel_192: bool) (temp___do_typ_inv_193: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_194 : int))
                      (temp___is_init_190 : bool))
                     (temp___skip_constant_191 : bool))
                    (temp___do_toplevel_192 : bool))
                   (temp___do_typ_inv_193 : bool)) }
  
  predicate default_initial_assumption (temp___expr_195: int) (temp___skip_top_level_196: bool) =
    true
  
  val default_initial_assumption (temp___expr_195: int) (temp___skip_top_level_196: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_195 : int))
                   (temp___skip_top_level_196 : bool)) }
end

module Selfdrivingcar__gearbox___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__gearbox as Selfdrivingcar__gearbox
  
  predicate dynamic_invariant (temp___expr_166: int) (temp___is_init_162: bool) (temp___skip_constant_163: bool) (temp___do_toplevel_164: bool) (temp___do_typ_inv_165: bool) =
    if ((temp___is_init_162 = True) \/
          (Selfdrivingcar__gearbox.first <= Selfdrivingcar__gearbox.last)) then
      (((Selfdrivingcar__gearbox.dynamic_property
           Selfdrivingcar__gearbox.first)
          Selfdrivingcar__gearbox.last)
         temp___expr_166)
    else true
  
  val dynamic_invariant (temp___expr_166: int) (temp___is_init_162: bool) (temp___skip_constant_163: bool) (temp___do_toplevel_164: bool) (temp___do_typ_inv_165: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_166 : int))
                      (temp___is_init_162 : bool))
                     (temp___skip_constant_163 : bool))
                    (temp___do_toplevel_164 : bool))
                   (temp___do_typ_inv_165 : bool)) }
  
  predicate default_initial_assumption (temp___expr_167: int) (temp___skip_top_level_168: bool) =
    true
  
  val default_initial_assumption (temp___expr_167: int) (temp___skip_top_level_168: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_167 : int))
                   (temp___skip_top_level_168 : bool)) }
end

module Selfdrivingcar__sensor___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  
  predicate dynamic_invariant (temp___expr_173: int) (temp___is_init_169: bool) (temp___skip_constant_170: bool) (temp___do_toplevel_171: bool) (temp___do_typ_inv_172: bool) =
    if ((temp___is_init_169 = True) \/
          (Selfdrivingcar__sensor.first <= Selfdrivingcar__sensor.last)) then
      (((Selfdrivingcar__sensor.dynamic_property Selfdrivingcar__sensor.first)
          Selfdrivingcar__sensor.last)
         temp___expr_173)
    else true
  
  val dynamic_invariant (temp___expr_173: int) (temp___is_init_169: bool) (temp___skip_constant_170: bool) (temp___do_toplevel_171: bool) (temp___do_typ_inv_172: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_173 : int))
                      (temp___is_init_169 : bool))
                     (temp___skip_constant_170 : bool))
                    (temp___do_toplevel_171 : bool))
                   (temp___do_typ_inv_172 : bool)) }
  
  predicate default_initial_assumption (temp___expr_174: int) (temp___skip_top_level_175: bool) =
    true
  
  val default_initial_assumption (temp___expr_174: int) (temp___skip_top_level_175: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_174 : int))
                   (temp___skip_top_level_175 : bool)) }
end

module Selfdrivingcar__ignition___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__ignition as Selfdrivingcar__ignition
  
  predicate dynamic_invariant (temp___expr_180: int) (temp___is_init_176: bool) (temp___skip_constant_177: bool) (temp___do_toplevel_178: bool) (temp___do_typ_inv_179: bool) =
    if ((temp___is_init_176 = True) \/
          (Selfdrivingcar__ignition.first <= Selfdrivingcar__ignition.last)) then
      (((Selfdrivingcar__ignition.dynamic_property
           Selfdrivingcar__ignition.first)
          Selfdrivingcar__ignition.last)
         temp___expr_180)
    else true
  
  val dynamic_invariant (temp___expr_180: int) (temp___is_init_176: bool) (temp___skip_constant_177: bool) (temp___do_toplevel_178: bool) (temp___do_typ_inv_179: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_180 : int))
                      (temp___is_init_176 : bool))
                     (temp___skip_constant_177 : bool))
                    (temp___do_toplevel_178 : bool))
                   (temp___do_typ_inv_179 : bool)) }
  
  predicate default_initial_assumption (temp___expr_181: int) (temp___skip_top_level_182: bool) =
    true
  
  val default_initial_assumption (temp___expr_181: int) (temp___skip_top_level_182: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_181 : int))
                   (temp___skip_top_level_182 : bool)) }
end

module Selfdrivingcar__diagnostics___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__diagnostics as Selfdrivingcar__diagnostics
  
  predicate dynamic_invariant (temp___expr_187: int) (temp___is_init_183: bool) (temp___skip_constant_184: bool) (temp___do_toplevel_185: bool) (temp___do_typ_inv_186: bool) =
    if ((temp___is_init_183 = True) \/
          (Selfdrivingcar__diagnostics.first
             <= Selfdrivingcar__diagnostics.last)) then
      (((Selfdrivingcar__diagnostics.dynamic_property
           Selfdrivingcar__diagnostics.first)
          Selfdrivingcar__diagnostics.last)
         temp___expr_187)
    else true
  
  val dynamic_invariant (temp___expr_187: int) (temp___is_init_183: bool) (temp___skip_constant_184: bool) (temp___do_toplevel_185: bool) (temp___do_typ_inv_186: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_187 : int))
                      (temp___is_init_183 : bool))
                     (temp___skip_constant_184 : bool))
                    (temp___do_toplevel_185 : bool))
                   (temp___do_typ_inv_186 : bool)) }
  
  predicate default_initial_assumption (temp___expr_188: int) (temp___skip_top_level_189: bool) =
    true
  
  val default_initial_assumption (temp___expr_188: int) (temp___skip_top_level_189: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_188 : int))
                   (temp___skip_top_level_189 : bool)) }
end

module Selfdrivingcar__batterypercentage___axiom
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  
  predicate dynamic_invariant (temp___expr_201: int) (temp___is_init_197: bool) (temp___skip_constant_198: bool) (temp___do_toplevel_199: bool) (temp___do_typ_inv_200: bool) =
    if ((temp___is_init_197 = True) \/
          (Selfdrivingcar__batterypercentage.first
             <= Selfdrivingcar__batterypercentage.last)) then
      (((Selfdrivingcar__batterypercentage.dynamic_property
           Selfdrivingcar__batterypercentage.first)
          Selfdrivingcar__batterypercentage.last)
         temp___expr_201)
    else true
  
  val dynamic_invariant (temp___expr_201: int) (temp___is_init_197: bool) (temp___skip_constant_198: bool) (temp___do_toplevel_199: bool) (temp___do_typ_inv_200: bool) : 
    bool
    ensures { result
                <->
                (((((dynamic_invariant (temp___expr_201 : int))
                      (temp___is_init_197 : bool))
                     (temp___skip_constant_198 : bool))
                    (temp___do_toplevel_199 : bool))
                   (temp___do_typ_inv_200 : bool)) }
  
  predicate default_initial_assumption (temp___expr_202: int) (temp___skip_top_level_203: bool) =
    true
  
  val default_initial_assumption (temp___expr_202: int) (temp___skip_top_level_203: bool) : 
    bool
    ensures { result
                <->
                ((default_initial_assumption (temp___expr_202 : int))
                   (temp___skip_top_level_203 : bool)) }
end

module Selfdrivingcar__mycar___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Selfdrivingcar__applyacceleratorpedal__speedlimit___axiom
  use _gnatprove_standard.Main
  use int.Int
end

module Selfdrivingcar__applyacceleratorpedal__subprogram_def
  use _gnatprove_standard.Main
  use int.Int
  use int.Int
  use _gnatprove_standard.Main as Main
  use _gnatprove_standard.Boolean as Boolean
  use Selfdrivingcar__mycar as Selfdrivingcar__mycar
  use Selfdrivingcar__car as Selfdrivingcar__car
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__invariant as Selfdrivingcar__invariant
  use Selfdrivingcar__invariant___axiom as Selfdrivingcar__invariant___axiom
  use Selfdrivingcar__applyacceleratorpedal__speedlimit as Selfdrivingcar__applyacceleratorpedal__speedlimit
  use Selfdrivingcar__sensor as Selfdrivingcar__sensor
  use Selfdrivingcar__sensor__rep as Selfdrivingcar__sensor__rep
  use Selfdrivingcar__speed as Selfdrivingcar__speed
  use Selfdrivingcar__speed___axiom as Selfdrivingcar__speed___axiom
  use Selfdrivingcar__speed__rep as Selfdrivingcar__speed__rep
  use Selfdrivingcar__batterypercentage as Selfdrivingcar__batterypercentage
  use Selfdrivingcar__batterypercentage__rep as Selfdrivingcar__batterypercentage__rep
  use Selfdrivingcar__gearbox___axiom as Selfdrivingcar__gearbox___axiom
  use Selfdrivingcar__sensor___axiom as Selfdrivingcar__sensor___axiom
  use Selfdrivingcar__ignition___axiom as Selfdrivingcar__ignition___axiom
  use Selfdrivingcar__diagnostics___axiom as Selfdrivingcar__diagnostics___axiom
  use Selfdrivingcar__speed___axiom as Selfdrivingcar__speed___axiom
  use Selfdrivingcar__batterypercentage___axiom as Selfdrivingcar__batterypercentage___axiom
  use Selfdrivingcar__car___axiom as Selfdrivingcar__car___axiom
  use Selfdrivingcar__mycar___axiom as Selfdrivingcar__mycar___axiom
  use Selfdrivingcar__invariant___axiom as Selfdrivingcar__invariant___axiom
  use Selfdrivingcar__applyacceleratorpedal__speedlimit___axiom as Selfdrivingcar__applyacceleratorpedal__speedlimit___axiom
  
  let def (__void_param : unit)
    requires { [#"selfdrivingcar.ads" 53 0 0] true }
    ensures { [#"selfdrivingcar.ads" 53 0 0]
              [#"selfdrivingcar.ads" 57 0 0]
              [@GP_Reason:VC_POSTCONDITION]
              [@comment:       Post => Invariant and (myCar.currentSpeed <= speedLimit);                ^ selfdrivingcar.ads:57:16:VC_POSTCONDITION]
              [@GP_Sloc:selfdrivingcar.ads:57:16]
              [@model_vc_post]
              [@GP_Id:2]
              [@GP_Shape:pragargs__and]
              (([@GP_Sloc:selfdrivingcar.ads:57:16]
                [@GP_Pretty_Ada:1057]
                ((epsilon temp___result_236: bool.
                    ((temp___result_236
                        = (Selfdrivingcar__invariant.invariant__
                             (Selfdrivingcar__car.__split_fields__content
                                 Selfdrivingcar__mycar.mycar__split_fields))) /\
                       ((Selfdrivingcar__invariant.invariant____function_guard
                           temp___result_236)
                          (Selfdrivingcar__car.__split_fields__content
                              Selfdrivingcar__mycar.mycar__split_fields))))
                   = True)) /\
                 ([@GP_Pretty_Ada:1063]
                  [@GP_Sloc:selfdrivingcar.ads:57:30]
                  ((Selfdrivingcar__speed__rep.to_rep
                      ((Selfdrivingcar__car.__split_fields
                           { Selfdrivingcar__car.__split_fields =
                               (Selfdrivingcar__car.__split_fields__content
                                   Selfdrivingcar__mycar.mycar__split_fields) }).
                         Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                     <= Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit))) }
  = [@vc:divergent]
    (([@GNAT-comment:Assume dynamic invariants of inputs of the subprogram selfdrivingcar.ads:53]
      ());
     assume {
       ((((Selfdrivingcar__car___axiom.dynamic_invariant
             { Selfdrivingcar__car.__split_fields =
                 (Selfdrivingcar__car.__split_fields__content
                     Selfdrivingcar__mycar.mycar__split_fields) })
            True)
           False)
          True)
         True };
     assume {
       ((((Selfdrivingcar__speed___axiom.dynamic_invariant
             Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit)
            True)
           False)
          True)
         True };
     ([@GNAT-comment:Assume moved pointers in outputs of the subprogram selfdrivingcar.ads:53]
      ());
     ([@GNAT-comment:Check for RTE in the Pre of the subprogram selfdrivingcar.ads:53]
      ());
     (begin
        ensures { true }
        let _ =
          let _ =
            (Boolean.andb
               ((Boolean.andb
                   (Selfdrivingcar__invariant___axiom.invariant__ ()))
                  (((Selfdrivingcar__speed__rep.to_rep
                       ((Selfdrivingcar__car.__split_fields
                            { Selfdrivingcar__car.__split_fields =
                                (Selfdrivingcar__car.__split_fields__content
                                    Selfdrivingcar__mycar.mycar__split_fields) }).
                          Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                      + (1 : int))
                     <= Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit)))
              ((Selfdrivingcar__sensor__rep.to_rep
                  ((Selfdrivingcar__car.__split_fields
                       { Selfdrivingcar__car.__split_fields =
                           (Selfdrivingcar__car.__split_fields__content
                               Selfdrivingcar__mycar.mycar__split_fields) }).
                     Selfdrivingcar__car.rec__selfdrivingcar__car__objectscanner))
                 = (1 : int)) in
          () in
        ()
      end);
     ([@GNAT-comment:Assume Pre of the subprogram selfdrivingcar.ads:53] ());
     assume {
       ((([@GP_Pretty_Ada:1039]
          ((epsilon temp___result_235: bool.
              ((temp___result_235
                  = (Selfdrivingcar__invariant.invariant__
                       (Selfdrivingcar__car.__split_fields__content
                           Selfdrivingcar__mycar.mycar__split_fields))) /\
                 ((Selfdrivingcar__invariant.invariant____function_guard
                     temp___result_235)
                    (Selfdrivingcar__car.__split_fields__content
                        Selfdrivingcar__mycar.mycar__split_fields))))
             = True)) /\
           ([@GP_Pretty_Ada:1047]
            (((Selfdrivingcar__speed__rep.to_rep
                 ((Selfdrivingcar__car.__split_fields
                      { Selfdrivingcar__car.__split_fields =
                          (Selfdrivingcar__car.__split_fields__content
                              Selfdrivingcar__mycar.mycar__split_fields) }).
                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                + (1 : int))
               <= Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit))) /\
          ([@GP_Pretty_Ada:1053]
           ((Selfdrivingcar__sensor__rep.to_rep
               ((Selfdrivingcar__car.__split_fields
                    { Selfdrivingcar__car.__split_fields =
                        (Selfdrivingcar__car.__split_fields__content
                            Selfdrivingcar__mycar.mycar__split_fields) }).
                  Selfdrivingcar__car.rec__selfdrivingcar__car__objectscanner))
              = (1 : int)))) };
     (try
        ([@GP_Sloc:selfdrivingcar.adb:18:7] [#"selfdrivingcar.adb" 18 0 0] ());
        ([@GP_Sloc:selfdrivingcar.adb:18:29]
         [#"selfdrivingcar.adb" 18 0 0] ());
        ([@GP_Sloc:selfdrivingcar.adb:18:26]
         [#"selfdrivingcar.adb" 18 0 0]
         (let temp___231 =
            let temp___230 =
              { Selfdrivingcar__car.__split_fields =
                  (Selfdrivingcar__car.__split_fields__content
                      Selfdrivingcar__mycar.mycar__split_fields) } in
            ([#"selfdrivingcar.adb" 18 0 0]
             (begin
                ensures { true }
                let _ =
                  let _ =
                    (Selfdrivingcar__car.__split_fields temp___230).Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed in
                  () in
                ()
              end));
            ({ temp___230 with
               Selfdrivingcar__car.__split_fields =
                 ({ (Selfdrivingcar__car.__split_fields temp___230) with
                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed =
                      (Selfdrivingcar__speed__rep.of_rep
                         ([#"selfdrivingcar.adb" 18 0 0]
                          [@GP_Sloc:selfdrivingcar.adb:18:48]
                          [@vc:annotation]
                          [@GP_Shape:mycar_assign__add]
                          [@GP_Reason:VC_RANGE_CHECK]
                          [@GP_Id:1]
                          [@comment:      myCar.currentSpeed := myCar.currentSpeed + 1;                                                ^ selfdrivingcar.adb:18:48:VC_RANGE_CHECK]
                          (Selfdrivingcar__speed.range_check_
                             ((Selfdrivingcar__speed__rep.to_rep
                                 ((Selfdrivingcar__car.__split_fields
                                      { Selfdrivingcar__car.__split_fields =
                                          (Selfdrivingcar__car.__split_fields__content
                                              Selfdrivingcar__mycar.mycar__split_fields) }).
                                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                                + (1 : int))))) }) }) in
          Selfdrivingcar__mycar.mycar__split_fields.Selfdrivingcar__car.__split_fields__content <-
            (Selfdrivingcar__car.__split_fields temp___231)));
        ([@GP_Sloc:selfdrivingcar.adb:19:11]
         [#"selfdrivingcar.adb" 19 0 0] ());
        ([@GP_Sloc:selfdrivingcar.adb:19:7]
         [#"selfdrivingcar.adb" 19 0 0]
         (if (([#"selfdrivingcar.adb" 19 0 0]
               [#"selfdrivingcar.adb" 19 0 0]
               (([@branch_id=862] Main.spark__branch).bool__content <-
                  ((Selfdrivingcar__batterypercentage__rep.to_rep
                      ((Selfdrivingcar__car.__split_fields
                           { Selfdrivingcar__car.__split_fields =
                               (Selfdrivingcar__car.__split_fields__content
                                   Selfdrivingcar__mycar.mycar__split_fields) }).
                         Selfdrivingcar__car.rec__selfdrivingcar__car__batterycharge))
                     < (15 : int))));
              (([@branch_id=862] Main.spark__branch).bool__content)) then
            (([@GP_Sloc:selfdrivingcar.adb:22:10]
              [#"selfdrivingcar.adb" 22 0 0] ());
             ([@GP_Sloc:selfdrivingcar.adb:22:32]
              [#"selfdrivingcar.adb" 22 0 0] ());
             ([@GP_Sloc:selfdrivingcar.adb:22:29]
              [#"selfdrivingcar.adb" 22 0 0]
              (let temp___234 =
                 let temp___233 =
                   { Selfdrivingcar__car.__split_fields =
                       (Selfdrivingcar__car.__split_fields__content
                           Selfdrivingcar__mycar.mycar__split_fields) } in
                 ([#"selfdrivingcar.adb" 22 0 0]
                  (begin
                     ensures { true }
                     let _ =
                       let _ =
                         (Selfdrivingcar__car.__split_fields temp___233).
                           Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed in
                       () in
                     ()
                   end));
                 ({ temp___233 with
                    Selfdrivingcar__car.__split_fields =
                      ({ (Selfdrivingcar__car.__split_fields temp___233) with
                         Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed =
                           (Selfdrivingcar__speed__rep.of_rep
                              (Selfdrivingcar__speed__rep.to_rep
                                 ((Selfdrivingcar__car.__split_fields
                                      { Selfdrivingcar__car.__split_fields =
                                          (Selfdrivingcar__car.__split_fields__content
                                              Selfdrivingcar__mycar.mycar__split_fields) }).
                                    Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))) }) }) in
               [#"selfdrivingcar.adb" 22 0 0]
               (Selfdrivingcar__mycar.mycar__split_fields.Selfdrivingcar__car.__split_fields__content <-
                  (Selfdrivingcar__car.__split_fields temp___234)))))
          else ()));
        (raise Return__exc)
      with Return__exc -> ()
      end);
     (begin
        ensures { true }
        let _ =
          let _ =
            (Boolean.andb (Selfdrivingcar__invariant___axiom.invariant__ ()))
              ((Selfdrivingcar__speed__rep.to_rep
                  ((Selfdrivingcar__car.__split_fields
                       { Selfdrivingcar__car.__split_fields =
                           (Selfdrivingcar__car.__split_fields__content
                               Selfdrivingcar__mycar.mycar__split_fields) }).
                     Selfdrivingcar__car.rec__selfdrivingcar__car__currentspeed))
                 <= Selfdrivingcar__applyacceleratorpedal__speedlimit.speedlimit) in
          () in
        ()
      end))
end
